# 一、绪论

## 1. Linux 版本

在2.6之前，版本号第二位表示稳定版和开发版。每个版本号用三个数字，由点分隔，前两个是版本号，第三个表示发布号。第二位为偶数为稳定版，奇数为开发版。

2.6 及其之后对内核编号进行改变，只有在对内核重大修改进行测试时，才会使用一个新的内核分支 2.7。

这样意味着如果具有相同的版本号，却有不同的发布号，如 2.6.10 和 2.6.11 可能在核心部件和基本算法上有很大的差别，具有新发布号的可能不稳定。所以就有了带有补丁程序的内核版本，第四个数字代表不同补丁的内核版本。

《深入理解 Linux 内核 3rd》使用的是 2.6.11 内核。

本文主要看《深入理解 Linux 内核 3rd》，2.6.11 版本内核，但是某些变化较大的地方，也会提及新版本的内核。



## 2. 文件系统

文件被组织成树结构。文件或目录名由除了 `"/"` 和 `"\0"`  之外的任意 ASCII 字符序列组成，通常有限制 255 个字符。每个进程有一个当前的工作目录，属于进程执行上下文，标识出进程的当前目录。

**硬链接和软链接(符号链接)**

**文件描述符和 inode**

除了设备文件和特殊文件系统文件之外，每个文件都是由字符序列组成。文件内容不包含任何的控制信息，比如文件长度或者 EOF。对于一些库调用判断 EOF，

文件系统处理的所有信息包含在一个 inode 的数据结构中，每个文件都有自己的 inode，文件系统用 inode 来标识文件。

inode 至少提供如下属性：文件类型、硬链接个数、文件长度(字节)、设备标识符、inode 号、UID、GID、几个时间戳、访问权限、文件模式

**访问权限和文件模式**

读、写、执行 和 user、group、other 组合为 9 种访问权限。

还有三种附加标记 `suid, sgid, sticky` 来定义文件模式。

**文件操作的系统调用**：`open, lseek, read, write, close, rename, unlink`



## 3. Unix 内核概述

**进程/内核模式**：用户态和内核态切换

**进程实现**：进程描述符(PC、SP、GR、FR、PSW、内存管理的寄存器等)

**可重入内核(*reentrant*)**：若干个进程可以同时在内核态下执行

**进程地址空间**：每个进程运行在私有地址空间。用户态下涉及私有栈、数据区、代码区。当在内核态运行时，进程访问内核的数据区和代码区，每个内核控制路径(和不同的进程有关)都有自己的私有内核栈。有时进程之间也会共享部分地址空间(共享内存、动态库)。`mmap` 调用允许存放在块设备的数据一部分映射到进程的部分地址空间。

**同步和临界区**：信号量、自旋锁(多处理器下阻塞时间较短的情况下)，避免死锁问题

**信号(*signal*)和进程间通信(*IPC*)**：信号量、消息队列(`msgsnd/msgget`)、共享内存(`shmget/shmat/shmdt`)

**进程管理**：`fork/exec/_exit` 分别用来创建一个进程，装入一个程序，终止一个进程。

- **僵尸进程**：完成执行(通过 `exit` 系统调用，或运行时发生致命错误或收到终止信号所致)但在操作系统的进程表中仍然有一个表项(进程控制块 *PCB*)，处于 " <u>终止状态</u>" 的进程。用于父进程读取子进程的退出状态等。

    在有终止状态的子进程时，父进程执行 `wait`[^1]  允许系统释放子进程关联的资源。如果父进程没有调用 `wait`  的话，已终止的子进程将一直保持“僵死”状态。

    子进程在状态发生改变之后，系统发送 `SIGCHLD` 信号给父进程，父进程默认忽略。父进程通常在 `SIGCHLD` 信号处理程序中，使用 `wait` 来响应子进程的终止。如果父进程显示设置 `SIG_IGN` 忽略 `SIGCHLD` 信号，或者具有 `SA_NOCLDWAIT` 标志，所有子进程的退出状态信息被抛弃并且直接被系统回收。

    `ps` 目录 `STAT` 列所示的 `Z` 为僵尸进程。

    回收僵尸进程的一种方法是通过 `kill` 命令手动向其父进程发送 `SIGCHLD` 信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得 `init` 进程收养僵尸进程。

    [^1]: 这里的 `wait` 表示泛指，详见 `wait/waitpid/wait4` 等，下同。

- **进程组**：shell 为 `ls | sort | more` 创建了一个进程组，每个进程的描述符包含一个进程组 ID。每个组有一个 leader 进程，其 PID 和进程组 ID 相同

- **登录会话**：Shell 控制的不是进程，而是作业(*Job*)。Shell 可以运行**一个前台作业**和**任意多个后台作业**。作业与进程组的区别：如果作业中的某个进程又创建了子进程，则子进程不属于作业。由于 Linux 是多用户系统，所以必须要支持多个用户同时使用一个操作系统。当一个用户登录一次系统就形成一次会话 。一个会话可包含多个进程组，但只能有一个前台进程组。一个会话可以有一个控制终端。建立与控制终端连接的会话首进程被称为控制进程。一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组。`bg` 和 `fg` 命令把一个 Job 放在前台或者后台。

**内存管理**

- **虚拟内存**：作为逻辑层，处于应用程序和内存管理单元之间。重点问题是虚拟地址空间。当使用虚拟地址时，内核和 MMU 协同定位其在内存中的物理地址。现代 CPU 有把虚拟地址转换为物理地址的硬件电路。所以引入页表来指定虚拟地址和物理地址之间的对应关系。
- **RAM 的使用**：一部分作为内核映像。其他部分作为虚拟内存系统。在十七章有页框回收问题。还有一个需要解决的问题时内存碎片问题。
- **内核内存分配器 KMA**： 满足系统中所有部分对内存的请求。在第八章可以看到 Linux 的 KMA 在伙伴系统之上使用了 Slab 分配算法。
- **进程虚拟空间处理**：包括该进程可以引用的所有虚拟内存地址，内核通过内存区域描述符列表来存储进程的虚拟地址空间，当进程通过 `exec` 类系统调用开始某个程序时，内核分配给该进程的虚拟地址空间包括：代码区、数据区、未初始化数据区(`.bss`)、用户态栈、所需共享库的可执行代码和数据、堆。
- **高速缓存 *cache* **：使用 RAM 来缓存磁盘数据，避免读磁盘。`sync()` 系统调用把所有脏的缓冲区写入磁盘强制磁盘同步，操作系统也会周期性把脏缓冲区写回磁盘。

**设备驱动程序**：包含在内核中。通过特定接口，驱动程序和内核其他部分相互作用。驱动程序封装在模块中。



