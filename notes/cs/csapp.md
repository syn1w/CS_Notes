温故而知新。之前已经看过一遍第二版的 CSAPP，当年还没有第三版，这次把第三版简单过一遍，查漏补缺，完成一些当时没有动手的 lab。

# 一、计算机系统漫游

信息就是**比特位 + 上下文**。在计算机中所有的数据都是比特位，在不同的上下文中，这些字节序列可以表示整型、浮点型、字符串、

机器指令等等。



C 源码编译过程：

```txt
                                            printf.o ----->
hello.c -----> hello.i -----> hello.s -----> hello.o -----> hello
         cpp             cc1            as             ld
```



计算机硬件组成：

- 总线，携带信息字节并负责在各个部件间传递。通常总线被设为传递定长的字节块，也就是**字(word)**。

- CPU(运算符、控制器)，解释(执行)存储在内存中的指令的引擎。所执行的指令模型由指令集架构决定。
- 存储器(内存)，内存由一组 DRAM 芯片组成，从逻辑上来说，内存就是一个线性的字节数组。
- I/O 设备，系统与外部世界联系的通道，每个 I/O 设备通过一个控制器(controller)或适配器(adapter)与 I/O 总线相连。



因为 CPU 速度比内存速度快的多，使用**局部性**原理，在 CPU 和内存之间添加了高速缓存，能够有效增加程序的执行效率。

存储器的体系结构：

![storage](../../imgs/cs/csapp1_1.png)

操作系统对硬件进行管理，应用程序通过操作系统提供的服务（接口）来对硬件进行访问。

**进程**是操作系统对一个正在运行程序的抽象，操作系统提供了一种假象，就好像系统上只有这个程序在运行。其实一个操作系统可以有多个进程，进行**并发**执行，一个进程的指令可以和另一个进程的指令交错执行。操作系统需要跟踪进程运行所需的所有状态信息，也叫**上下文(context)**。当操作系统将控制权从当前进程转移到另一个进程时，就会发生**上下文切换(context switch)**。

在现代系统中，一个进程中可以由多个称为**线程(thread)**的执行单元组成，每个线程都运行在进程的上下文中，并共享相同的代码和全局数据。

**虚拟内存**是一个抽象概念，为每个进程提供了一个假象，即每个进程都在独占使用内存。每个进程看到的内存都是一致的，被称为**虚拟地址空间**。

![virtual_memory](https://syn1w.github.io/2020/07/14/malloc-free/x86_linux_memory_layout.png)

上图是 x86-Linux 虚拟内存布局，x64 的和 x86 的虚拟内存布局类似，最大区别在可寻址范围。

虚拟内存包括（从下网上）：

- text segment 代码段，机器指令代码，只读。
- data segment 数据段，已初始化的全局变量和静态变量。
- BSS segment，未初始化的全局变量和静态变量（默认值为 0，只在虚拟内存预留空间，并不占可执行程序的硬盘空间）
- heap segment 堆段，运行时堆段，堆可以动态收缩和扩张。可以通过 `brk` 系统调用或 `sbrk` 或 `malloc/free` C 库间接调用 `brk` 动态调整堆段大小。
- memory mapping segment 内存映射段，详见 `mmap/munmap syscall`。文件（包括动态库）映射、通过 `malloc/free` 间接调用 `mmap/munmap` 进行大块内存分配（匿名映射）。
- stack segment 栈段，编译器使用它实现函数调用，用户栈在程序执行过程中会自动进行扩展和收缩。
- kernel space 内核空间，内核保留，用户空间不可访问。



多核处理器的组织结构：

![smp-cpu](../../imgs/cs/csapp1_2.png)

**抽象**是计算机科学中最为重要的概念之一。提供了不同的层次的抽象，大大降低了设计系统的复杂度。就操作系统对硬件功能进行了抽象，使得应用程序程序员不需要处理硬件的细节。

